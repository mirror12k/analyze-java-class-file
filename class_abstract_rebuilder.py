#!/usr/bin/env python


import sys

import classfile



def classNameToCode(classname):
	return classname.replace('/', '.')



def classConstantToName(const):
	if const.tagName != 'CONSTANT_Class':
		raise Exception('classConstantToName called with non-class constant: ' + str(const))

	name = const.nameIndex

	if name.tagName != 'CONSTANT_Utf8':
		raise Exception('classConstantToName called with non-string classname constant: ' + str(name))

	return classNameToCode(name.string)

def classConstantToSimpleName(const):
	if const.tagName != 'CONSTANT_Class':
		raise Exception('classConstantToSimpleName called with non-class constant: ' + str(const))

	name = const.nameIndex

	if name.tagName != 'CONSTANT_Utf8':
		raise Exception('classConstantToSimpleName called with non-string classname constant: ' + str(name))

	code = classNameToCode(name.string)
	if code.rfind('.') == -1:
		return code
	else:
		return code[code.rfind('.')+1:]


def classAccessFlagsToCode(flags):
	newflags = []
	for flag in flags:
		if flag == 'ACC_PUBLIC': # Declared public; may be accessed from outside its package.
			newflags.append('public')
		elif flag == 'ACC_FINAL': # Declared final; no subclasses allowed.
			newflags.append('final')
		elif flag == 'ACC_SUPER': # Treat superclass methods specially when invoked by the invokespecial instruction.
			pass
			# newflags.append()
		elif flag == 'ACC_INTERFACE': # Is an interface, not a class.
			newflags.append('interface')
		elif flag == 'ACC_ABSTRACT': # Declared abstract; must not be instantiated.
			newflags.append('abstract')
		elif flag == 'ACC_SYNTHETIC': # Declared synthetic; not present in the source code.
			newflags.append('SYNTHETIC')
		elif flag == 'ACC_ANNOTATION': # Declared as an annotation type.
			newflags.append('ANNOTATION')
		elif flag == 'ACC_ENUM': # Declared as an enum type.
			newflags.append('enum')
		else:
			raise Exception('invalid flag in class access flags: '+flag)
	return ' '.join(newflags)

def methodAccessFlagsToCode(flags):
	newflags = []
	for flag in flags:
		if flag == 'ACC_PUBLIC': # Declared public; may be accessed from outside its package.
			newflags.append('public')
		elif flag == 'ACC_PRIVATE': # Declared private; accessible only within the defining class.
			newflags.append('private')
		elif flag == 'ACC_PROTECTED': # Declared protected; may be accessed within subclasses.
			newflags.append('protected')
		elif flag == 'ACC_STATIC': # Declared static.
			newflags.append('static')
		elif flag == 'ACC_FINAL': # Declared final; must not be overridden.
			newflags.append('final')
		elif flag == 'ACC_SYNCHRONIZED': # Declared synchronized; invocation is wrapped by a monitor use.
			newflags.append('synchronized')
		elif flag == 'ACC_BRIDGE': # A bridge method, generated by the compiler.
			newflags.append('BRIDGE')
		elif flag == 'ACC_VARARGS': # Declared with variable number of arguments.
			newflags.append('VARARGS')
		elif flag == 'ACC_NATIVE': # Declared native; implemented in a language other than Java.
			newflags.append('native')
		elif flag == 'ACC_ABSTRACT': # Declared abstract; no implementation is provided.
			newflags.append('abstract')
		elif flag == 'ACC_STRICT': # Declared strictfp; floating-point mode is FP-strict.
			newflags.append('STRICT')
		elif flag == 'ACC_SYNTHETIC': # Declared synthetic; not present in the source code.
			newflags.append('SYNTHETIC')
		else:
			raise Exception('invalid flag in method access flags: '+flag)
	return ' '.join(newflags)


letterTypeToCode = {
	'V' : 'void',

	'i' : 'int',
	'l' : 'long',
	's' : 'short',
	'b' : 'byte',
	'c' : 'char',
	'f' : 'float',
	'd' : 'double',
	'z' : 'boolean',

	'a' : 'reference',
}

	
def typeToCode(typestr):
	arraydepth = 0
	while typestr[0] == '[':
		typestr = typestr[1:]
		arraydepth = arraydepth + 1

	if typestr[0] == 'L':
		return classNameToCode(typestr[1:-1]) + ('[]' * arraydepth)
	else:
		return letterTypeToCode[typestr] + ('[]' * arraydepth)

def methodDescriptorToCode(desc):
	if desc[0] != '(':
		raise Exception('invalid method description: '+desc)

	offset = 1
	argtypes = []
	while desc[offset] != ')':
		startoffset = offset
		while desc[offset] == '[':
			offset = offset + 1

		if desc[offset] == 'L':
			endoffset = offset + desc.find(';', offset) - 1
			offset = endoffset
		else:
			endoffset = offset
			offset = offset + 1

		typestr = desc[startoffset:endoffset]
		argtypes.append(typeToCode(typestr))

	retstr = desc[offset+1:]
	rettype = typeToCode(retstr)

	return (argtypes, rettype)





def main(args):
	if len(args) == 0:
		print("argument required")
	else:
		file = classfile.openFile(args[0])

		classDeclaration = classAccessFlagsToCode(file.fileStructure['access_flags']) + ' class ' + classConstantToName(file.fileStructure['this_class']) +\
				' extends ' + classConstantToName(file.fileStructure['super_class'])

		print classDeclaration + ' {'

		for method in file.fileStructure['methods']:
			argtypes, rettype = methodDescriptorToCode(method.descriptorIndex.string)
			methodname = method.nameIndex.string

			if methodname == '<clinit>':
				print '\t' + methodAccessFlagsToCode(method.accessFlags) + ' {'
				print '\t\t// code ...'
				print '\t}'
			else:
				if methodname == '<init>':
					methodname = classConstantToSimpleName(file.fileStructure['this_class'])

				print '\t' + methodAccessFlagsToCode(method.accessFlags) + ' ' + rettype + ' ' + methodname +\
						' (' + ', '.join(argtypes) + ') {'
				print '\t\t// code ...'
				print '\t}'

		print '}'




if __name__ == '__main__':
	main(sys.argv[1:])
